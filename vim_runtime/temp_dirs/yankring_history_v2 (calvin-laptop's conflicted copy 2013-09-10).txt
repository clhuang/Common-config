your_host_name,v
    return "PROXY proxy.lmsal.com:80";,V
#!/bin/bashWIRED_IP=`ifconfig eth0 | sed -ne 's/.*inet addr:\([^ ]*\).*/\1/p'`WIRELESS_IP=`ifconfig wlan0 | sed -ne 's/.*inet addr:\([^ ]*\).*/\1/p'`HOST_IP=${WIRED_IP:-$WIRELESS_IP}HOST_NAME="your_host_name"cat /etc/hosts.custom > /etc/hostscat >> /etc/hosts << EOF# This file is automatically generated by /sbin/hostname.sh$HOST_IP  $HOST_NAMEEOFexit 0,v
function FindProxyForURL(url, host){  if (isInNet(myIpAddress(), "1.2.3.0", "255.255.255.0")) {    if (isInNet(host, "192.168.0.0", "255.255.0.0"))      return "DIRECT";    if (shExpMatch(url, "http:*"))      return "PROXY my.proxy.com:8000" ;    if (shExpMatch(url, "https:*"))      return "PROXY my.proxy.com:8000" ;    if (shExpMatch(url, "ftp:*"))      return "PROXY my.proxy.com:8000" ;    return "DIRECT";  } else {    return "DIRECT";  }},v
  //if (isInNet(myIpAddress(), "172.20.3.0", "255.255.255.0")) {    //if (isInNet(host, "192.168.0.0", "255.255.0.0"))      //return "DIRECT";    //if (shExpMatch(url, "http:*"))      //return "PROXY proxy.lmsal.com:80" ;    //if (shExpMatch(url, "https:*"))      //return "PROXY proxy.lmsal.com:80" ;    //if (shExpMatch(url, "ftp:*"))      //return "PROXY proxy.lmsal.com:80" ;    //return "DIRECT";  //} else {    //return "DIRECT";  //},V
  if (isInNet(myIpAddress(), "172.20.3.0", "255.255.255.0")) {    if (isInNet(host, "192.168.0.0", "255.255.0.0"))      return "DIRECT";    if (shExpMatch(url, "http:*"))      return "PROXY proxy.lmsal.com:80" ;    if (shExpMatch(url, "https:*"))      return "PROXY proxy.lmsal.com:80" ;    if (shExpMatch(url, "ftp:*"))      return "PROXY proxy.lmsal.com:80" ;    return "DIRECT";  } else {    return "DIRECT";  },V
0,v
.,v
3,v
2,v
1,v
(myIpAddress(), "1,v
,V
git remote add origin ssh://git@bitbucket.org/calvin909090/nlp-categorization.git,v
m,v
),v
EmissivityCalc,v
q=rn.emissInteg(0,90,0,50*np.ones((640,640))),V
        if time == None:            time = timeRange[0],V
6,v
#-----------------------------------------------------------------------------------------,V
def ne_rt_table(rho, temp, order=1, tabfile=None):    ''' Calculates electron density by interpolating the rho/temp table.        Based on Mats Carlsson's ne_rt_table.pro.        IN: rho (in g/cm^3),            temp (in K),        OPTIONAL: order (interpolation order 1: linear, 3: cubic),                  tabfile (path of table file)        OUT: electron density (in g/cm^3)        '''    import os    import scipy.interpolate as interp    import scipy.ndimage as ndimage    from scipy.io.idl import readsav    print 'DEPRECATION WARNING: this method is deprecated in favour of the Rhoeetab class.'    if tabfile is None:        tabfile = 'ne_rt_table.idlsave'    # use table in default location if not found    if not os.path.isfile(tabfile) and \        os.path.isfile(os.getenv('TIAGO_DATA')+'/misc/'+tabfile):        tabfile = os.getenv('TIAGO_DATA')+'/misc/'+tabfile    tt = readsav(tabfile, verbose=False)    lgrho = N.log10(rho)    # warnings for values outside of table    tmin  = N.min(temp) ; tmax = N.max(temp)    ttmin = N.min(5040./tt['theta_tab']) ; ttmax = N.max(5040./tt['theta_tab'])    lrmin  = N.min(lgrho) ; lrmax = N.max(lgrho)    tlrmin = N.min(tt['rho_tab']) ; tlrmax = N.max(tt['rho_tab'])    if tmin < ttmin:        print('(WWW) ne_rt_table: temperature outside table bounds. ' +              'Table Tmin=%.1f, requested Tmin=%.1f' % (ttmin, tmin))    if tmax > ttmax:        print('(WWW) ne_rt_table: temperature outside table bounds. ' +              'Table Tmax=%.1f, requested Tmax=%.1f' % (ttmax, tmax))    if lrmin < tlrmin:        print('(WWW) ne_rt_table: log density outside of table bounds. ' +             'Table log(rho) min=%.2f, requested log(rho) min=%.2f' % (tlrmin, lrmin))    if lrmax > tlrmax:        print('(WWW) ne_rt_table: log density outside of table bounds. ' +             'Table log(rho) max=%.2f, requested log(rho) max=%.2f' % (tlrmax, lrmax))    ## Tiago: this is for the real thing, global fit 2D interpolation:    ##        (commented because it is TREMENDOUSLY SLOW)    #x = N.repeat(tt['rho_tab'],  tt['theta_tab'].shape[0])    #y = N.tile(  tt['theta_tab'],  tt['rho_tab'].shape[0])    ## 2D grid interpolation according to method (default: linear interpolation)    #result = interp.griddata(N.transpose([x,y]), tt['ne_rt_table'].ravel(),    #                         (lgrho, 5040./temp), method=method)    #    ## if some values outside of the table, use nearest neighbour    #if N.any(N.isnan(result)):    #    idx = N.isnan(result)    #    near = interp.griddata(N.transpose([x,y]), tt['ne_rt_table'].ravel(),    #                            (lgrho, 5040./temp), method='nearest')    #    result[idx] = near[idx]    ## Tiago: this is the approximate thing (bilinear/cubic interpolation) with ndimage    y = (5040./temp - tt['theta_tab'][0])/(tt['theta_tab'][1]-tt['theta_tab'][0])    x = (lgrho - tt['rho_tab'][0])/(tt['rho_tab'][1]-tt['rho_tab'][0])    result=ndimage.map_coordinates(tt['ne_rt_table'], [x,y], order=order, mode='nearest')    return 10**result*rho/tt['grph'],v
    __global__ void emissInteg(float *out, float *tau, float *xtau10, float *xtau) {        int idx = blockIdx.x * blockDim.x + threadIdx.x;        if (idx > projectionXsize * projectionYsize) return;        int ypixel = idx / projectionXsize;        int xpixel = idx %% projectionXsize;        float intensity = 0;        float emiss = 0;        float tausum = tau[idx];        float3 positionIncrement = viewVector * ds;        float3 currentPosition = initialCP(xpixel, ypixel);        float3 normalizedPosition;        if (currentPosition.x == INFINITY) {            out[idx] = 0;            return;        }        //Do this to attain the final position.        do {            currentPosition += positionIncrement;        } while (isInSlice(currentPosition));        currentPosition -= positionIncrement; //The last valid position.        normalizedPosition = realToNormalized(currentPosition);        do {            if (xtau[idx] <= xtau10[idx]) {                intensity = pointSpecificStuff(                        (normalizedPosition.x * xtotalsize - xstart) / (float) sliceWidth,                        normalizedPosition.y,                        normalizedPosition.z, true).x;                emiss += intensity * expf(-tausum);                tausum -= pointSpecificTau(                        (normalizedPosition.x * xtotalsize - xstart) / (float) sliceWidth,                        normalizedPosition.y,                        normalizedPosition.z);                //Don't take into account negative numbers.                 if (tausum < 0)                     tausum = 0;            }            currentPosition -= positionIncrement;            normalizedPosition = realToNormalized(currentPosition);            xtau[idx] -= 1;        } while (isInSlice(currentPosition));        out[idx] = emiss;        tau[idx] = tausum;    }    __global__ void tauRender(float *out, float *tauIn, float *xtau10, float *xtautotal) {        int idx = blockIdx.x * blockDim.x + threadIdx.x;        if (idx > projectionXsize * projectionYsize) return;        int ypixel = idx / projectionXsize;        int xpixel = idx %% projectionXsize;        float tausum = 0;        float3 positionIncrement = viewVector * ds;        float3 currentPosition = initialCP(xpixel, ypixel);        float3 normalizedPosition;        if (currentPosition.x == INFINITY) {            out[idx] = 0;            return;        }        do {            normalizedPosition = realToNormalized(currentPosition);            if (tausum + tauIn[idx] <= 1.e2) {                tausum += pointSpecificTau(                        (normalizedPosition.x * xtotalsize - xstart) / (float) sliceWidth,                        normalizedPosition.y,                        normalizedPosition.z);                 xtau10[idx] += 1;            }            currentPosition += positionIncrement;            xtautotal[idx] += 1;        } while (isInSlice(currentPosition));        xtautotal[idx] -= 1;        out[idx] = tausum;    },V
http://www.poll-maker.com/results28865x1d699c28-2,v
A,v
            tau[idx] = tausum;,V
            if curvature:                altitude = dtheta * (mdomain - cdomain),V
        if curvature:,V
small,v
        if lambd != DEFAULT_WAVE:            self.kaTable = self.opatab.h_he_absorb(lambd),V
        self.kaTable = self.opatab.h_he_absorb(lambd = 1 / self.ny0[channel]),V
sdomain + t,v
t,v
 ,v
-,v
            if curvature:,V
j,v
class curvRenderer:    def __init__(self, dataDir=os.path.expanduser('~')+'/LockheedData/ionimultdata', absorb=True):        self.sRend = Renderer(dataDir)        self.absorb = absorb        self.sRend.stepsize = 0.001        self.sRend.distancePerPixel = 0.064        self.sRend.projectionXsize = self.sRend.projectionYsize = 256    def multCont(sdomain, edomain, lambd, channel = 0, absorp=True, incAverage=False):        avex = []        tau = 0        emiss = 0        trange = edomain - sdomain        tau = None        for t in range(trange + 1):            sRend.setTime(edomain - t)            if absorp:                demiss, tau = sRend.emissInteg(channel, 90, 0, tau)            else:                demiss = sRend.iRender(channel, 90, 0)            emiss += demiss            if not incAverage:                avex.append(np.average(emiss, axis=1))        if incAverage:            return (emiss, avex)        return emiss,V
    def multCont(sdomain, edomain, lambd, incAverage=False):        avex = []        tau = 0        emiss = 0        trange = edomain - sdomain        tau = None        for t in range(trange + 1):            sRend.setTime(edomain - t)            demiss, tau = sRend.emissInteg(0, 90, 0, tau)            emiss += demiss            if not incAverage:                avex.append(np.average(emiss, axis=1))        if incAverage:            return (emiss, avex)        return emiss,V
    def multCont(sdomain, edomain, lambd, channel = 0, absorp=True, incAverage=False):        avex = []        tau = 0        emiss = 0        trange = edomain - sdomain        tau = None        for t in range(trange + 1):            sRend.setTime(edomain - t)            if absorp:                demiss, tau = sRend.emissInteg(channel, 90, 0, tau)            else:                demiss = sRend.iRender(channel, 90, 0)            emiss += demiss            if not incAverage:                avex.append(np.average(emiss, axis=1))        if incAverage:            return (emiss, avex)        return emiss,V
channel,v
    def __init__(self, dataDir=os.path.expanduser('~')+'/LockheedData/ionimultdata', absorb=True):        self.sRend = Renderer(dataDir)        self.absorb = absorb,V
    def __init__(self, dataDir=os.path.expanduser('~')+'/LockheedData/ionimultdata', absorb=True):        self.sRend = Renderer(dataDir)        self.absorb = absorb        self.sRend.stepsize = 0.001        self.sRend.distancePerPixel = 0.064        self.sRend.projectionXsize = self.sRend.projectionYsize = 256    def multCont(sdomain, edomain, lambd, incAverage=False):        avex = []        tau = 0        emiss = 0        trange = edomain - sdomain        tau = None        for t in range(trange + 1):            sRend.setTime(edomain - t)            demiss, tau = sRend.emissInteg(0, 90, 0, tau)            emiss += demiss            if not incAverage:                avex.append(np.average(emiss, axis=1))        if incAverage:            return (emiss, avex)        return emiss,V
640,v
average,v
            tau = None,V
BaseException,v
',v
a,v
o,v
l,v
f,v
=,v
e,v
p,v
y,v
d,v
,,v
z,v
i,v
s,v
X,v
n,v
c,v
r,v
Y,v
(,v
    def __init__(self, data,V
N,v
    def __init__(self,,V
    def __init__(self, dataDir=os.path.expanduser('~')+'/LockheedData/ionismalldata', time=261):,V
from scipy.interpolate import interp1d,V
c2_1335.6630.datc2_1335.7080.datdens.dateostable.datfe8_187.datfe9_188.datfe10_184.datfe11_188.datfe12_186.datfe12_188.datfe13_185.datfe14_185.datgpuparam.txthe2_303.dationization.dationization1d.datkappatab303.786.datmesh.datnetg_radtab.datqsmag_bb01_it120.auxqsmag_bb01_it120.idlqsmag_bb01_it120.idl~qsmag_bb01_it120.snapqsmag_bb01_it121.auxqsmag_bb01_it121.idlqsmag_bb01_it121.snapqsmag_bb01_it122.auxqsmag_bb01_it122.idlqsmag_bb01_it122.snapqsmag_bb01_it123.auxqsmag_bb01_it123.idlqsmag_bb01_it123.snapqsmag_bb01_it124.auxqsmag_bb01_it124.idlqsmag_bb01_it124.snapqsmag_bb01_it125.auxqsmag_bb01_it125.idlqsmag_bb01_it125.snapqsmag_bb01_it126.auxqsmag_bb01_it126.idlqsmag_bb01_it126.snapqsmag_bb01_it127.auxqsmag_bb01_it127.idlqsmag_bb01_it127.snapqsmag_bb01_it128.auxqsmag_bb01_it128.idlqsmag_bb01_it128.snapqsmag_bb01_it129.auxqsmag_bb01_it129.idlqsmag_bb01_it129.snapqsmag_bb01_it130.auxqsmag_bb01_it130.idlqsmag_bb01_it130.idl~qsmag_bb01_it130.snapqsmag_bb01_it131.auxqsmag_bb01_it131.idlqsmag_bb01_it131.snapqsmag_bb01_it132.auxqsmag_bb01_it132.idlqsmag_bb01_it132.snapqsmag_bb01_it133.auxqsmag_bb01_it133.idlqsmag_bb01_it133.snapqsmag_bb01_it134.auxqsmag_bb01_it134.idlqsmag_bb01_it134.snapqsmag_bb01_it135.auxqsmag_bb01_it135.idlqsmag_bb01_it135.snapqsmag_bb01_it136.auxqsmag_bb01_it136.idlqsmag_bb01_it136.snapqsmag_bb01_it137.auxqsmag_bb01_it137.idlqsmag_bb01_it137.snapqsmag_bb01_it138.auxqsmag_bb01_it138.idlqsmag_bb01_it138.snapqsmag_bb01_it139.auxqsmag_bb01_it139.idlqsmag_bb01_it139.snapqsmag_bb01_it140.auxqsmag_bb01_it140.idlqsmag_bb01_it140.snapqsmag_bb01_it141.auxqsmag_bb01_it141.idlqsmag_bb01_it141.snapqsmag_bb01_it142.auxqsmag_bb01_it142.idlqsmag_bb01_it142.snapqsmag_bb01_it143.auxqsmag_bb01_it143.idlqsmag_bb01_it143.snapqsmag_bb01_it144.auxqsmag_bb01_it144.idlqsmag_bb01_it144.snapqsmag_bb01_it145.auxqsmag_bb01_it145.idlqsmag_bb01_it145.snapqsmag_bb01_it146.auxqsmag_bb01_it146.idlqsmag_bb01_it146.snapqsmag_bb01_it147.auxqsmag_bb01_it147.idlqsmag_bb01_it147.snapqsmag_bb01_it148.auxqsmag_bb01_it148.idlqsmag_bb01_it148.snapqsmag_bb01_it149.auxqsmag_bb01_it149.idlqsmag_bb01_it149.snapqsmag_bb01_it150.auxqsmag_bb01_it150.idlqsmag_bb01_it150.snapqsmag_bb01_it151.auxqsmag_bb01_it151.idlqsmag_bb01_it151.snapqsmag_bb01_it152.auxqsmag_bb01_it152.idlqsmag_bb01_it152.snapqsmag_bb01_it220.auxqsmag_bb01_it220.idlqsmag_bb01_it220.snapqsmag_bb01_it221.auxqsmag_bb01_it221.idlqsmag_bb01_it221.snapqsmag_bb01_it222.auxqsmag_bb01_it222.idlqsmag_bb01_it222.snapqsmag_bb01_it223.auxqsmag_bb01_it223.idlqsmag_bb01_it223.snaprhoei_radtab.dattableint.dattableint304.dattableintall.dattableopall.dattabparam.intemp.dat,v
from pycuda.compiler import SourceModule,V
import pycuda.autoinit,V
import pycuda.driver as cuda,V
from ..bifrost import OSC_data,V
from ..bifrost import Rhoeetab,V
from ..bifrost import Opatab,V
import osimport math as mimport numpy as npfrom scipy.interpolate import interp1dimport pycuda.driver as cudaimport pycuda.autoinitfrom pycuda.compiler import SourceModulefrom ..bifrost import OSC_datafrom ..bifrost import Rhoeetabfrom ..bifrost import Opatab,V
largedata,v
        cuda.memcpy_htod(self.mod.get_global('xPixelOffset')[0], np.float32(self.xPixelOffset))        cuda.memcpy_htod(self.mod.get_global('yPixelOffset')[0], np.float32(self.yPixelOffset)),V
import pycuda.gpuarray as gpuarrayimport pycuda.driver as cudaimport pycuda.autoinitimport numpya_gpu = gpuarray.to_gpu(numpy.random.randn(4,4).astype(numpy.float32))a_doubled = (2*a_gpu).get()print a_doubledprint a_gpu,V
I,v
u,v
+,v
x,v
*,v
        if tauI == None:            tauI = np.zeros((self.projectionYsize, self.projectionXsize), dtype='float32'),V
tau,v
out,v
cuda.Out(tau),,v
_,v
    def tauRender(channel, azimuth, altitude, tauIn, xtau10, xtautotal, lambd):        #Defining kaTable for the opacity        if lambd != DEFAULT_WAVE:          self.kaTable = self.opatab.h_he_absorb(lambd)        viewX, viewY, viewVector = viewAxes(azimuth, altitude)        #Loading all the data and tables into GPU memory as arrays        atex = self.mod.get_texref('atex') #nedbin*ntgbin        atex.set_flags(0)        cuda.matrix_to_texref(self.acontTables[channel], atex, order='F')        atex.set_flags(cuda.TRSF_NORMALIZED_COORDINATES)        atex.set_filter_mode(cuda.filter_mode.LINEAR)        atex.set_address_mode(0, cuda.address_mode.CLAMP)        atex.set_address_mode(1, cuda.address_mode.CLAMP)        entex = self.mod.get_texref('entex') #neibin*nrhobin        entex.set_flags(0)        cuda.matrix_to_texref(self.neTable, entex, order='F')        entex.set_flags(cuda.TRSF_NORMALIZED_COORDINATES)        entex.set_filter_mode(cuda.filter_mode.LINEAR)        entex.set_address_mode(0, cuda.address_mode.CLAMP)        entex.set_address_mode(1, cuda.address_mode.CLAMP)        tgtex = self.mod.get_texref('tgtex') #neibin*nrhobin        tgtex.set_flags(0)        cuda.matrix_to_texref(self.tgTable, tgtex, order='F')        tgtex.set_flags(cuda.TRSF_NORMALIZED_COORDINATES)        tgtex.set_filter_mode(cuda.filter_mode.LINEAR)        tgtex.set_address_mode(0, cuda.address_mode.CLAMP)        tgtex.set_address_mode(1, cuda.address_mode.CLAMP)        katex = self.mod.get_texref('katex')        katex.set_flags(0)        cuda.matrix_to_texref(self.kaTable, katex, order='F')        katex.set_flags(cuda.TRSF_NORMALIZED_COORDINATES)        katex.set_filter_mode(cuda.filter_mode.LINEAR)        katex.set_address_mode(0, cuda.address_mode.CLAMP)        katex.set_address_mode(1, cuda.address_mode.CLAMP)        iztex = self.mod.get_texref('iztex') #zsize*1        iztex.set_flags(0)        cuda.matrix_to_texref(np.reshape(self.izaxis, (self.izaxis.size, 1)), iztex, order='F')        iztex.set_flags(cuda.TRSF_NORMALIZED_COORDINATES)        iztex.set_filter_mode(cuda.filter_mode.LINEAR)        print 'Loaded textures'        xsplitsize = MAXGRIDSIZE / (self.yaxis.size * self.zaxis.size)        numSplits = (self.xaxis.size + xsplitsize - 1) / xsplitsize        datout = np.zeros((self.projectionYsize, self.projectionXsize), dtype='float32')        tempout = np.empty_like(datout)        d_xtau10 = cuda.mem_alloc(xtau10.nbytes)        cuda.memcpy_htod(d_xtau10, xtau10)        d_xtautotal = cuda.mem_alloc(xtautotal.nbytes)        cuda.memcpy_htod(d_xtautotal, xtautotal)        cuda.memcpy_htod(self.mod.get_global('viewVector')[0], viewVector)        cuda.memcpy_htod(self.mod.get_global('viewX')[0], viewX)        cuda.memcpy_htod(self.mod.get_global('viewY')[0], viewY)        cuda.memcpy_htod(self.mod.get_global('ds')[0], np.float32(self.stepsize))        cuda.memcpy_htod(self.mod.get_global('projectionXsize')[0], np.int32(self.projectionXsize))        cuda.memcpy_htod(self.mod.get_global('projectionYsize')[0], np.int32(self.projectionYsize))        cuda.memcpy_htod(self.mod.get_global('distancePerPixel')[0], np.float32(self.distancePerPixel))        for i in range(numSplits):            xstart = i * xsplitsize #starting x position            if xstart + xsplitsize > self.xaxis.size: #reduce size of output arrays                xsplitsize = self.xaxis.size - xstart            print 'Rendering x\'-coords ' + str(xstart) + '-' + str(xstart + xsplitsize) + ' of ' + str(self.xaxis.size)            dtex = self.mod.get_texref('dtex') #x*y*z            darray = numpy3d_to_array(self.r[xstart:xstart+xsplitsize].copy('F'), 'F')            dtex.set_array(darray)            dtex.set_flags(cuda.TRSF_NORMALIZED_COORDINATES)            dtex.set_filter_mode(cuda.filter_mode.LINEAR)            eetex = self.mod.get_texref('eetex') #x*y*z            eearray = numpy3d_to_array(self.e[xstart:xstart+xsplitsize].copy('F'), 'F')            eetex.set_array(eearray)            eetex.set_flags(cuda.TRSF_NORMALIZED_COORDINATES)            eetex.set_filter_mode(cuda.filter_mode.LINEAR)            dataSize = self.projectionXsize * self.projectionYsize            gridSize = (dataSize + BLOCKSIZE - 1) / BLOCKSIZE            cuda.memcpy_htod(self.mod.get_global('xstart')[0], np.int32(xstart))            cuda.memcpy_htod(self.mod.get_global('sliceWidth')[0], np.int32(xsplitsize))            frender = self.mod.get_function('tauRender')            #integrates to find tau            frender(cuda.Out(tempout), cuda.InOut(tauIn), d_xtau10, d_xtautotal,                    block=(BLOCKSIZE,1,1), grid=(gridSize,1,1))            cuda.memcpy_dtoh(xtau10, d_xtau10)            cuda.memcpy_dtoh(xtautotal, d_xtautotal)            datout += tempout        return datout,V
        d_tau = cuda.mem_alloc(tau.nbytes)        cuda.memcpy_htod(d_tau, tau)        d_xtau10 = cuda.mem_alloc(xtau10.nbytes)        cuda.memcpy_htod(d_xtau10, xtau10)        d_xtau = cuda.mem_alloc(xtau.nbytes)        cuda.memcpy_htod(d_xtau, xtau),V
            #Transferring the data back            cuda.memcpy_dtoh(tau, d_tau)            cuda.memcpy_dtoh(xtau10, d_xtau10)            cuda.memcpy_dtoh(xtau, d_xtau),V
b,v
    app = iRenderApp(rend),V
ir.setRend(q),v
    channel = 0,V
